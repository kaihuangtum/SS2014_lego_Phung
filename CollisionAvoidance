/* Wir betrachten zwei Fälle

1. Fall Kollisionsdaten von Jens <- Objekt abgeschnitten. 
Falls Kollisionspunkt kleiner als Eckpunkte
	
2. Falls Kollisionspunkt größer als Eckpunkte 
*/

package Test // from Jens code

public class CollisionAvoidance {
/* This function gets the outer points of the objects. We receive an array with the coordinate of the object which can be seen by the car.
size of the objectarray  n = "defined size", -> int objectarray [n] [2] (i.e. the coordinate (4/7) in objectarray [0] -> objectarray [0] [0] = 4,
obectarray [0] [1] = 7
*/

//A better idea is maybe to calculate it with sin and cos.
//compass_input noch nicht vorhanden!
public int[][] getOuterPoints(int[][] objectarray, int compass_input){
	int angle = angleCheck(compass_input);
	int [][] outerPoints;
	int [][] result;
	int j = 0;
	int m = 0;
	int min_x = 100000;
	int min_y = 100000;
	int max_x = 100000;
	int max_y = 100000;
	int rel_x;
	//case 1
	if(angle > 0 && angle < 90){
		for(int i = 1; i < objectarray.length; i++){
			while(objectarray[i][0] != null && objectarray[i][1] != null){
				if(objectarray [i-1][1] < objectarray [i] [1] &&  objectarray [i-1][1] <= min_y){	
					min_y = objectarray[i-1][1];
					rel_x = objectarray[i-1][0];
					if ( min_y < outerPoints[j][1]){
						outerPoints[j][1] = min_y;
						outerPoints[j][1] = rel_x;
					}else if (min_y == outerPoints[j][1]){
						j++;
						outerPoints[j][1] = min_y;
						outerpoints[j][0] = rel_x;
				}
				else if(objectarray [i-1][1] > objectarray [i] [1]){
					outerPoints[j][1] = objectarray[i][1];
				}
				j++;
			}
			if(outerPoints.length > 1){
				for(int n=1;x<outerPoints.length; x++){
					if(outerPoints[n-1][0] < outerPoints[n][0]){
						result[m][0] = outerPoints[n][0];
					}
					else
				}
			}
			
		}
		
		}
	}
	
	
	
	
	
	
	
	
	
	//First outer point at max_value [0] [z], second outer point at max_value [1] [z] with z = 0 for x_value or 1 for y_value 
	int max_value [][]= new int [2] [2];
	// looking for the greatest y_value
	for(int i = 1; i < objectarray.length; i ++){
		if(int [i-1][1] < int [i] [1]){
			max_value [0] [0] = int [i] [0];
			max_value [0] [1] = int [i] [1];
		}
		if(int [i-1] [0] < int [i] && int [i-1] [1] > int [i] [1]){
			max_value [1] [0] = int [i] [0];
			max_value [1] [1] = int [i] [1];
		}
		
	}
	
	return max_value;
	
}

//Returns the points where the car could drive to

public int[][] getNextPoint(){
	int[][] avoidancepoints = getOuterPoints(objectarray,car_x,car_y);
	//which value to add?
	//1st point +2 or -2 or 2nd point?
	avoidancepoints[0][1]+=2; 
	avoidancepoints[1][1]-=2;
	return avoidancepoints;
}

//Chooses one point to drive to

public void changePath(){
	int[][] avPoints = getNextPoint();
	car_x = avPoints[1][0];
	car_y = avPoints[1][1];
}


}
