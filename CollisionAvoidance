/* Wir betrachten zwei Fälle

1. Fall Kollisionsdaten von Jens <- Objekt abgeschnitten. 
Falls Kollisionspunkt kleiner als Eckpunkte
	
2. Falls Kollisionspunkt größer als Eckpunkte 
*/

package Test // from Jens code

public class CollisionAvoidance {
/* This function gets the outer points of the objects. We receive an array with the coordinate of the object which can be seen by the car.
size of the objectarray  n = "defined size", -> int objectarray [n] [2] (i.e. the coordinate (4/7) in objectarray [0] -> objectarray [0] [0] = 4,
obectarray [0] [1] = 7
*/

//A better idea is maybe to calculate it with sin and cos.
public int[][] getOuterPoints(int[][] objectarray, int car_x, int car_y){
	
	//First outer point at max_value [0] [z], second outer point at max_value [1] [z] with z = 0 for x_value or 1 for y_value 
	int max_value [][]= new max_value [2] [2];
	// looking for the greatest y_value
	for(int i = 1; i < objectarray.length; i ++){
		if(int [i-1][1] < int [i] [1]){
			max_value [0] [0] = int [i] [0];
			max_value [0] [1] = int [i] [1];
		}
		if(int [i-1] [0] < int [i] && int [i-1] [1] > int [i] [1]){
			max_value [1] [0] = int [i] [0];
			max_value [1] [1] = int [i] [1];
		}
		
	}
	
	return max_value;
	
}

//Returns the points where the car could drive to

public int[][] getNextPoint(){
	int[][] avoidancepoints = getOuterPoints(objectarray,car_x,car_y);
	//which value to add?
	//1st point +2 or -2?
	avoidancepoints[1][0]+2; 
	avoidancepoints[0][0]-2;
	return avoidancepoints;
}

//Chooses one point to drive to

public void changePath(){
	int[][] avPoints = getNextPoint();
	car_x = avPoints[1][0];
	car_y = avPoints[1][1];
}

public boolean isSpecialCase(int collisionpoint_X, int collisionpoint_Y, int[][] objectarray){
	for(int i = 0; i < objectarray.length;i++){
		
	}
	return false;
}

}
