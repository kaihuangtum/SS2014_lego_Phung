/* Wir betrachten zwei Fälle

1. Fall Kollisionsdaten von Jens <- Objekt abgeschnitten. 
Falls Kollisionspunkt kleiner als Eckpunkte
	
2. Falls Kollisionspunkt größer als Eckpunkte 
*/

package Test // from Jens code

public class CollisionAvoidance {
/* This function gets the outer points of the objects. We receive an array with the coordinate of the object which can be seen by the car.
size of the objectarray  n = "defined size", -> int objectarray [n] [2] (i.e. the coordinate (4/7) in objectarray [0] -> objectarray [0] [0] = 4,
obectarray [0] [1] = 7
*/

//A better idea is maybe to calculate it with sin and cos.
//compass_input noch nicht vorhanden!
public static int[][] getOuterPoints(int[][] objectarray, int compass_input) {
		int angle = 45;
		int[][] outerPoints = new int[5][2];
		for(int n =0; n < outerPoints.length; n++){
			outerPoints[n][0] = 100000;
			outerPoints[n][1] = 100000;
		}
		int[][] result;
		int j = 0;
		int m = 0;
		int min_x = 100000;
		int min_y = 100000;
		int max_x = 100000;
		int max_y = 100000;
		int rel_x;
		// case 1
		if (angle > 0 && angle < 90) {

			for (int i = 1; i < objectarray.length; i++) {
				if (objectarray[i - 1] == null) {
					System.out.println("break");
					break;
				}
				if (objectarray[i - 1][1] < objectarray[i][1]
						&& objectarray[i - 1][1] <= min_y) {
					System.out.println("if1");
					min_y = objectarray[i - 1][1];
					rel_x = objectarray[i - 1][0];
					if (min_y < outerPoints[j][1]) {
						System.out.println("if2");
						outerPoints[j][1] = min_y;
						outerPoints[j][0] = rel_x;
						j++;
					} else if (min_y == outerPoints[j][1]) {
						System.out.println("else if1");
						outerPoints[j][1] = min_y;
						outerPoints[j][0] = rel_x;
						j++;
					}
				} else if (objectarray[i - 1][1] > objectarray[i][1]
						&& objectarray[i][1] <= min_y) {
					System.out.println("else if 2");
					min_y = objectarray[i][1];
					rel_x = objectarray[i][0];
					if (min_y < outerPoints[j][1]) {
						System.out.println("if3");
						outerPoints[j][1] = min_y;
						outerPoints[j][1] = rel_x;
						j++;
					} else if (min_y == outerPoints[j][1]) {
						System.out.println("else if 3");
						outerPoints[j][1] = min_y;
						outerPoints[j][0] = rel_x;
						j++;
					}
				}
			}

		}

		return outerPoints;
	}
//Returns the points where the car could drive to

public int[][] getNextPoint(){
	int[][] avoidancepoints = getOuterPoints(objectarray,car_x,car_y);
	//which value to add?
	//1st point +2 or -2 or 2nd point?
	avoidancepoints[0][1]+=2; 
	avoidancepoints[1][1]-=2;
	return avoidancepoints;
}

//Chooses one point to drive to

public void changePath(){
	int[][] avPoints = getNextPoint();
	car_x = avPoints[1][0];
	car_y = avPoints[1][1];
}


}
